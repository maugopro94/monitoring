<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Monitoring — Recherche + Carte + Stats</title>

  <!-- MapLibre (WebGL) -->
  <link href="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.css" rel="stylesheet"/>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <style>
    :root{
      --bg:#0b1020; --panel:#111a33; --panel2:#0f1730;
      --text:#e8eeff; --muted:#aab6de; --border:rgba(255,255,255,.12);
      --accent:#6aa6ff;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--text)}
    .app{display:grid;grid-template-columns:340px 1fr;height:100vh;overflow:hidden}
    .sidebar{background:linear-gradient(180deg,var(--panel),var(--panel2));border-right:1px solid var(--border);padding:16px;overflow:auto}
    .brand{display:flex;gap:10px;align-items:center;margin-bottom:12px}
    .dot{width:12px;height:12px;border-radius:999px;background:var(--accent);box-shadow:0 0 16px rgba(106,166,255,.6)}
    .brand h1{font-size:16px;margin:0}
    .brand p{margin:0;color:var(--muted);font-size:12px}
    .card{border:1px solid var(--border);border-radius:14px;padding:12px;margin-bottom:12px;background:rgba(255,255,255,.03)}
    .card h2{font-size:13px;margin:0 0 10px;color:var(--muted);font-weight:700}
    label{display:block;font-size:12px;color:var(--muted);margin:10px 0 6px}
    input,select{width:100%;padding:10px;border-radius:10px;border:1px solid var(--border);background:rgba(255,255,255,.04);color:var(--text);outline:none}
    select{color-scheme:dark}
    select option{background:var(--panel);color:var(--text)}
    input::placeholder{color:rgba(232,238,255,.45)}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .btns{display:flex;gap:10px;margin-top:12px}
    button{flex:1;padding:10px 12px;border-radius:10px;border:1px solid var(--border);background:rgba(106,166,255,.14);color:var(--text);cursor:pointer;font-weight:700}
    button.secondary{background:rgba(255,255,255,.06)}
    button:disabled{opacity:.55;cursor:not-allowed}
    .hint{font-size:11px;color:var(--muted);line-height:1.4;margin:10px 0 0}
    .kpis{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .kpi{border:1px solid var(--border);border-radius:14px;padding:10px;background:rgba(255,255,255,.03)}
    .kpi .v{font-size:18px;font-weight:900}
    .kpi .l{font-size:11px;color:var(--muted);margin-top:2px}

    .main{display:grid;grid-template-rows:58px 1fr;overflow:hidden}
    .topbar{display:flex;align-items:center;justify-content:space-between;padding:10px 14px;border-bottom:1px solid var(--border);background:rgba(255,255,255,.02)}
    .tabs{display:flex;gap:8px}
    .tab{padding:10px 12px;border-radius:12px;border:1px solid var(--border);background:rgba(255,255,255,.04);cursor:pointer;font-weight:800;font-size:13px;color:var(--muted);user-select:none}
    .tab.active{color:var(--text);background:rgba(106,166,255,.16);box-shadow:0 0 0 2px rgba(106,166,255,.08) inset}
    .status{font-size:12px;color:var(--muted);display:flex;gap:10px;align-items:center}
    .pill{padding:6px 10px;border-radius:999px;border:1px solid var(--border);background:rgba(255,255,255,.04)}
    .pill.ok{border-color:rgba(106,166,255,.4);color:var(--text)}
    .pill.error{border-color:rgba(255,122,122,.6);color:#ffd5d5;background:rgba(255,122,122,.12)}
    .pill.loading{opacity:.8}

    .content{position:relative;overflow:hidden}
    .view{position:absolute;inset:0;display:none}
    .view.active{display:block}
    #map{width:100%;height:100%}

    .tableWrap,.statsWrap{height:100%;overflow:auto;padding:14px}
    table{width:100%;border-collapse:collapse;border-radius:14px;overflow:hidden;border:1px solid var(--border);background:rgba(255,255,255,.03)}
    th,td{padding:10px;border-bottom:1px solid var(--border);font-size:13px;text-align:left;vertical-align:top}
    th{color:var(--muted);font-weight:800;background:rgba(255,255,255,.02);position:sticky;top:0}
    tr:hover td{background:rgba(106,166,255,.06)}
    .small{font-size:11px;color:var(--muted)}
    .pagination{display:flex;gap:8px;align-items:center;justify-content:flex-end;margin-top:10px}
    .pagination button{flex:unset;padding:8px 10px}

    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .chartCard{border:1px solid var(--border);border-radius:14px;padding:12px;background:rgba(255,255,255,.03)}
    .chartCard h3{margin:0 0 10px;font-size:13px;color:var(--muted)}
    canvas{max-width:100%}

    .maplibregl-popup-content{
      background:rgba(17,26,51,.95);color:var(--text);border:1px solid var(--border);
      border-radius:12px;box-shadow:0 14px 40px rgba(0,0,0,.35);padding:10px;font-family:inherit
    }
    .maplibregl-popup-close-button{color:var(--muted)}
    .popupTitle{font-weight:900;margin-bottom:4px}
    .popupRow{font-size:12px;color:var(--muted);margin:2px 0}
    .popupActions{display:flex;gap:8px;margin-top:8px}
    .popupBtn{padding:6px 8px;border-radius:8px;border:1px solid var(--border);background:rgba(106,166,255,.16);color:var(--text);cursor:pointer;font-size:11px;font-weight:700}
    .rowClickable td{cursor:pointer}
    .notice{padding:14px}
    .notice b{color:var(--text)}
  </style>
</head>

<body>
<div class="app">
  <aside class="sidebar">
    <div class="brand">
      <div class="dot"></div>
      <div>
        <h1>Explorer les observations</h1>
        <p>Backend WAMP (PHP) · MapLibre (si WebGL actif)</p>
      </div>
    </div>

    <div class="card">
      <h2>Filtres</h2>

      <label>Recherche texte</label>
      <input id="q" placeholder="Espèce, site, zone, famille, code..." />

      <label>Zone</label>
      <select id="zone">
        <option value="">Toutes</option>
      </select>

      <label>Site</label>
      <select id="site">
        <option value="">Tous</option>
      </select>

      <label>Famille</label>
      <input id="famille" placeholder="Ex: Ardeidae" />

      <div class="row">
        <div>
          <label>Date début</label>
          <input id="dateFrom" type="date"/>
        </div>
        <div>
          <label>Date fin</label>
          <input id="dateTo" type="date"/>
        </div>
      </div>

      <div class="row">
        <div>
          <label>Effectif min</label>
          <input id="countMin" type="number" min="0" placeholder="0"/>
        </div>
        <div>
          <label>Effectif max</label>
          <input id="countMax" type="number" min="0" placeholder=""/>
        </div>
      </div>

      <div class="btns">
        <button id="btnSearch">Rechercher</button>
        <button id="btnReset" class="secondary">Réinitialiser</button>
      </div>

      <p class="hint">
        Les requêtes partent vers <b>api.php</b> avec <b>route=...</b>.
        Si la carte ne marche pas (WebGL désactivé), utilise l’onglet Tableau/Statistiques.
      </p>
    </div>

    <div class="card">
      <h2>Résumé</h2>
      <div class="kpis">
        <div class="kpi"><div class="v" id="kpiObs">–</div><div class="l">Observations</div></div>
        <div class="kpi"><div class="v" id="kpiSpecies">–</div><div class="l">Espèces uniques</div></div>
        <div class="kpi"><div class="v" id="kpiSites">–</div><div class="l">Sites</div></div>
        <div class="kpi"><div class="v" id="kpiZones">–</div><div class="l">Zones</div></div>
      </div>
    </div>
  </aside>

  <main class="main">
    <div class="topbar">
      <div class="tabs">
        <div class="tab active" data-tab="mapView" id="tabMap">Carte</div>
        <div class="tab" data-tab="tableView">Tableau</div>
        <div class="tab" data-tab="statsView">Statistiques</div>
      </div>
      <div class="status">
        <span class="pill" id="resultPill">0 résultat</span>
        <span class="pill" id="netPill">API</span>
      </div>
    </div>

    <div class="content">
      <div id="mapView" class="view active">
        <div id="map"></div>
      </div>

      <div id="tableView" class="view">
        <div class="tableWrap">
          <table>
            <thead>
              <tr>
                <th>Date</th>
                <th>Espèce / Titre</th>
                <th>Famille</th>
                <th>Zone</th>
                <th>Site</th>
                <th>Effectif</th>
              </tr>
            </thead>
            <tbody id="tableBody"></tbody>
          </table>
          <div class="pagination">
            <span class="small" id="pageInfo">Page 1</span>
            <button id="prevPage" class="secondary">◀</button>
            <button id="nextPage" class="secondary">▶</button>
          </div>
        </div>
      </div>

      <div id="statsView" class="view">
        <div class="statsWrap">
          <div class="grid2">
            <div class="chartCard">
              <h3>Observations par mois</h3>
              <canvas id="chartTime"></canvas>
            </div>
            <div class="chartCard">
              <h3>Top espèces (wiCode)</h3>
              <canvas id="chartTopSpecies"></canvas>
            </div>
            <div class="chartCard">
              <h3>Top sites</h3>
              <canvas id="chartTopSites"></canvas>
            </div>
            <div class="chartCard">
              <h3>Top zones</h3>
              <canvas id="chartZones"></canvas>
            </div>
            <div class="chartCard">
              <h3>Répartition par famille</h3>
              <canvas id="chartFamilies"></canvas>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>
</div>

<script src="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.js"></script>
<script>
/** CONFIG **/
const DEMO_MODE = false; // ✅ demandé
const API_BASE = "api.php"; // ✅ demandé
const NET_LABEL = DEMO_MODE ? "Mode démo" : "API";

const SITE_COORDS_URL = "data/zone_coords.json";
const SITE_COLORS = ["#4DD0E1","#26A69A","#66BB6A","#DCE775","#FFCA28","#FFA726","#FF7043","#EF5350","#EC407A","#AB47BC","#5C6BC0","#42A5F5"];
const CHART_COLORS = ["#4DD0E1","#66BB6A","#FFCA28","#FF7043","#EF5350","#5C6BC0","#26A69A","#FFA726","#EC407A","#42A5F5"];
const CHART_LINE = "#6aa6ff";

/** State / Helpers **/
const $ = (id) => document.getElementById(id);

const state = { tab:"mapView", page:1, page_size:25, filters:{}, requestId:0, loading:false };
let siteCoords = {};
let siteCoordIndex = {};
let siteGeojson = null;
let zoneNames = new Set();

function setTab(tabId){
  state.tab = tabId;
  document.querySelectorAll(".tab").forEach(t => t.classList.toggle("active", t.dataset.tab === tabId));
  document.querySelectorAll(".view").forEach(v => v.classList.toggle("active", v.id === tabId));
  if (tabId === "mapView" && map) setTimeout(()=>map.resize(), 50);
}

function escapeHtml(s){
  return String(s ?? "").replace(/[&<>"']/g, c => ({
    "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#039;"
  }[c]));
}

function hashString(str){
  let h = 0;
  for (let i = 0; i < str.length; i++) {
    h = ((h << 5) - h) + str.charCodeAt(i);
    h |= 0;
  }
  return h;
}

function normalizeKey(value){
  let v = String(value ?? "").trim();
  if (!v) return "";
  if (typeof v.normalize === "function") {
    v = v.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
  }
  v = v.toUpperCase().replace(/\s+/g, " ").trim();
  return v;
}

function buildSiteCoordIndex(coords){
  const index = {};
  Object.entries(coords || {}).forEach(([name, coord]) => {
    index[name] = coord;
    const norm = normalizeKey(name);
    if (norm) index[norm] = coord;
  });
  const special = {
    TECHNOPOLE: ["TECHNOPOLE", "TECHNOPOLE DAKAR", "TECHNOPOLE DE DAKAR"],
    MBEUBEUSS: ["MBEUBEUSS", "LAC MBEUBEUSS"]
  };
  Object.entries(special).forEach(([key, aliases]) => {
    const found = aliases.map(a => index[a] || index[normalizeKey(a)]).find(Boolean);
    if (found) {
      index[key] = found;
      aliases.forEach(a => {
        index[a] = found;
        const norm = normalizeKey(a);
        if (norm) index[norm] = found;
      });
    }
  });
  return index;
}

function resolveSiteCoords(name){
  if (!name) return null;
  const direct = siteCoordIndex[name];
  if (direct) return direct;
  const norm = normalizeKey(name);
  if (siteCoordIndex[norm]) return siteCoordIndex[norm];
  if (norm.includes("TECHNOPOLE") && siteCoordIndex.TECHNOPOLE) return siteCoordIndex.TECHNOPOLE;
  if (norm.includes("MBEUBEUSS") && siteCoordIndex.MBEUBEUSS) return siteCoordIndex.MBEUBEUSS;
  return null;
}

function colorFromName(name){
  const idx = Math.abs(hashString(name)) % SITE_COLORS.length;
  return SITE_COLORS[idx];
}

function buildPalette(count){
  const colors = [];
  for (let i = 0; i < count; i++) {
    colors.push(CHART_COLORS[i % CHART_COLORS.length]);
  }
  return colors;
}

function buildSiteGeojson(coords){
  const features = [];
  const names = Object.keys(coords || {});
  for (const name of names) {
    const c = coords[name];
    const lat = Number(c && c.lat);
    const lon = Number(c && c.lon);
    if (!Number.isFinite(lat) || !Number.isFinite(lon)) continue;
    features.push({
      type:"Feature",
      properties:{ site:name, site_norm:normalizeKey(name), color:colorFromName(name), lat, lon },
      geometry:{ type:"Point", coordinates:[lon, lat] }
    });
  }
  return { type:"FeatureCollection", features };
}

function populateSiteOptions(names){
  const select = $("site");
  const current = select.value;
  select.innerHTML = "<option value=''>Tous</option>";
  const sorted = [...names].sort((a,b)=>a.localeCompare(b));
  for (const s of sorted){
    const opt = document.createElement("option");
    opt.value = s; opt.textContent = s;
    select.appendChild(opt);
  }
  if (current && sorted.includes(current)) {
    select.value = current;
  }
}

function ensureSelectOption(select, value){
  if (!value) return;
  const exists = Array.from(select.options).some(opt => opt.value === value);
  if (!exists) {
    const opt = document.createElement("option");
    opt.value = value;
    opt.textContent = value;
    select.appendChild(opt);
  }
}

function applyZoneFilter(zone, targetTab="tableView"){
  if (!zone) return;
  const zoneSelect = $("zone");
  ensureSelectOption(zoneSelect, zone);
  zoneSelect.value = zone;
  zoneSelect.dispatchEvent(new Event("change"));
  $("site").value = "";
  updateSelectedSiteLayer("");
  setTab(targetTab);
  runSearch();
}

function applySiteFilter(site, targetTab="tableView"){
  if (!site) return;
  const siteSelect = $("site");
  ensureSelectOption(siteSelect, site);
  siteSelect.value = site;
  $("zone").value = "";
  updateSelectedSiteLayer(site);
  setTab(targetTab);
  runSearch();
  if (targetTab === "mapView") {
    focusSelectedSite(site);
  }
}

function createPopupContent(title, rows, actions){
  const wrap = document.createElement("div");
  const t = document.createElement("div");
  t.className = "popupTitle";
  t.textContent = title;
  wrap.appendChild(t);
  rows.forEach(({ label, value }) => {
    const row = document.createElement("div");
    row.className = "popupRow";
    row.textContent = `${label} : ${value ?? ""}`;
    wrap.appendChild(row);
  });
  if (Array.isArray(actions) && actions.length) {
    const actionWrap = document.createElement("div");
    actionWrap.className = "popupActions";
    actions.forEach(({ label, onClick })=>{
      if (!label || typeof onClick !== "function") return;
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "popupBtn";
      btn.textContent = label;
      btn.addEventListener("click", (e)=>{
        e.stopPropagation();
        onClick();
      });
      actionWrap.appendChild(btn);
    });
    if (actionWrap.childNodes.length) {
      wrap.appendChild(actionWrap);
    }
  }
  return wrap;
}

function setNetStatus(mode, text){
  const el = $("netPill");
  el.classList.remove("ok","error","loading");
  if (mode) el.classList.add(mode);
  el.textContent = text;
}

function setLoading(isLoading){
  state.loading = isLoading;
  $("btnSearch").disabled = isLoading;
  $("btnReset").disabled = isLoading;
}

function paramsFromFilters(filters){
  const p = new URLSearchParams();
  for (const [k,v] of Object.entries(filters)){
    if (v !== "" && v != null) p.set(k, v);
  }
  return p;
}

function buildParams(route, params = {}){
  const p = new URLSearchParams({ route });
  for (const [k,v] of Object.entries(params)){
    if (v !== "" && v != null) p.set(k, v);
  }
  return p;
}

function buildParamsWithFilters(route, extra = {}){
  const p = paramsFromFilters(state.filters);
  p.set("route", route);
  for (const [k,v] of Object.entries(extra)){
    if (v !== "" && v != null) p.set(k, v);
  }
  return p;
}

function readIntInput(id){
  const raw = $(id).value;
  if (raw === "") return "";
  const val = Number.parseInt(raw, 10);
  return Number.isFinite(val) && val >= 0 ? String(val) : "";
}

function collectFilters(){
  return {
    q: $("q").value.trim(),
    zone: $("zone").value,
    site: $("site").value,
    famille: $("famille").value.trim(),
    date_from: $("dateFrom").value || "",
    date_to: $("dateTo").value || "",
    count_min: readIntInput("countMin"),
    count_max: readIntInput("countMax")
  };
}

async function safeFetchJson(url){
  const res = await fetch(url);
  const text = await res.text(); // <- lit le message même en cas d'erreur

  if (!res.ok) {
    throw new Error(`HTTP ${res.status} on ${url}\n\n${text}`);
  }

  try {
    return JSON.parse(text);
  } catch {
    throw new Error(`Réponse non-JSON sur ${url}\n\n${text}`);
  }
}

async function apiGet(route, params = {}){
  const p = buildParams(route, params);
  return safeFetchJson(API_BASE + "?" + p.toString());
}

async function apiGetWithFilters(route, extra = {}){
  const p = buildParamsWithFilters(route, extra);
  return safeFetchJson(API_BASE + "?" + p.toString());
}

/** Backend calls **/
async function fetchZones(){
  const data = await apiGet("filters/zones");
  return data.items || [];
}
async function fetchSites(zone=""){
  const params = {};
  if (zone) params.zone = zone;
  const data = await apiGet("filters/sites", params);
  return data.items || [];
}
async function fetchTable(){
  return apiGetWithFilters("observations", {
    page: String(state.page),
    page_size: String(state.page_size),
  });
}
async function fetchStats(){
  return apiGetWithFilters("observations/stats");
}
async function fetchGeo(useBbox=false){
  const extra = { limit:"20000" };
  if (useBbox && map){
    const b = map.getBounds();
    extra.bbox = [b.getWest(), b.getSouth(), b.getEast(), b.getNorth()].join(",");
  }
  return apiGetWithFilters("observations/geo", extra);
}

async function fetchSiteCoords(){
  const data = await safeFetchJson(SITE_COORDS_URL);
  siteCoordIndex = buildSiteCoordIndex(data || {});
  return data || {};
}

function shouldUseBboxForGeo(){
  return !(state.filters && state.filters.site);
}

/** KPI **/
function updateKpis(k){
  $("kpiObs").textContent = k.observations ?? "–";
  $("kpiSpecies").textContent = k.species ?? "–";
  $("kpiSites").textContent = k.sites ?? "–";
  $("kpiZones").textContent = k.zones ?? "–";
}
function setStatusPills(total){
  $("resultPill").textContent = `${total} résultat${total>1?"s":""}`;
}

/** Table **/
function renderTable(data){
  const body = $("tableBody");
  body.innerHTML = "";
  const items = data.items || [];
  if (!items.length) {
    const tr = document.createElement("tr");
    tr.innerHTML = `<td colspan="6" class="small">Aucun résultat</td>`;
    body.appendChild(tr);
  } else {
    items.forEach(row => {
      const tr = document.createElement("tr");
      tr.classList.add("rowClickable");
      tr.dataset.site = row.site ?? "";
      tr.dataset.zone = row.zone ?? "";
      tr.innerHTML = `
        <td>${escapeHtml(row.date ?? "")}<div class="small">#${escapeHtml(row.doc_id ?? "")}</div></td>
        <td>${escapeHtml(row.title ?? "")}</td>
        <td>${escapeHtml(row.famille ?? "")}</td>
        <td>${escapeHtml(row.zone ?? "")}</td>
        <td>${escapeHtml(row.site ?? "")}</td>
        <td>${escapeHtml(row.effectif ?? "")}</td>
      `;
      tr.addEventListener("click", ()=>{
        const site = tr.dataset.site || "";
        const zone = tr.dataset.zone || "";
        if (site) {
          applySiteFilter(site, "mapView");
        } else if (zone) {
          applyZoneFilter(zone, "mapView");
        }
      });
      body.appendChild(tr);
    });
  }
  const page = data.page ?? state.page;
  const pageSize = data.page_size ?? state.page_size;
  const total = data.total ?? 0;
  $("pageInfo").textContent = `Page ${page} · ${pageSize}/page · Total ${total}`;
  $("prevPage").disabled = (page <= 1);
  $("nextPage").disabled = (page * pageSize) >= total;
  setStatusPills(total);
}

/** Charts **/
let chartTime, chartTopSpecies, chartTopSites, chartZones, chartFamilies;
function renderCharts(stats){
  updateKpis(stats.kpis || {});
  const timeLabels = (stats.time || []).map(x => x.label);
  const timeValues = (stats.time || []).map(x => x.value);

  chartTime?.destroy();
  chartTime = new Chart($("chartTime"), { type:"line",
    data:{ labels:timeLabels, datasets:[{
      label:"Observations",
      data:timeValues,
      borderColor:CHART_LINE,
      backgroundColor:"rgba(106,166,255,0.22)",
      pointRadius:2,
      tension:0.25,
      fill:true
    }] },
    options:{ responsive:true, plugins:{ legend:{ display:false } } }
  });

  const spLabels = (stats.top_species || []).map(x => x.label);
  const spValues = (stats.top_species || []).map(x => x.value);
  chartTopSpecies?.destroy();
  chartTopSpecies = new Chart($("chartTopSpecies"), { type:"bar",
    data:{ labels:spLabels, datasets:[{
      label:"Occurences",
      data:spValues,
      backgroundColor:buildPalette(spLabels.length),
      borderColor:"#0b1020",
      borderWidth:1
    }] },
    options:{ responsive:true, plugins:{ legend:{ display:false } } }
  });

  const siteLabels = (stats.top_sites || []).map(x => x.label);
  const siteValues = (stats.top_sites || []).map(x => x.value);
  chartTopSites?.destroy();
  chartTopSites = new Chart($("chartTopSites"), { type:"bar",
    data:{ labels:siteLabels, datasets:[{
      label:"Observations",
      data:siteValues,
      backgroundColor:buildPalette(siteLabels.length),
      borderColor:"#0b1020",
      borderWidth:1
    }] },
    options:{ responsive:true, plugins:{ legend:{ display:false } } }
  });
  chartTopSites.options.onClick = (event, elements)=>{
    if (!elements || !elements.length) return;
    const idx = elements[0].index;
    const label = chartTopSites.data.labels[idx];
    applySiteFilter(label, "mapView");
  };
  if (chartTopSites.canvas) chartTopSites.canvas.style.cursor = "pointer";
  chartTopSites.update();

  const zoneLabels = (stats.zones || []).map(x => x.label);
  const zoneValues = (stats.zones || []).map(x => x.value);
  chartZones?.destroy();
  chartZones = new Chart($("chartZones"), { type:"bar",
    data:{ labels:zoneLabels, datasets:[{
      label:"Observations",
      data:zoneValues,
      backgroundColor:buildPalette(zoneLabels.length),
      borderColor:"#0b1020",
      borderWidth:1
    }] },
    options:{ responsive:true, plugins:{ legend:{ display:false } } }
  });
  chartZones.options.onClick = (event, elements)=>{
    if (!elements || !elements.length) return;
    const idx = elements[0].index;
    const label = chartZones.data.labels[idx];
    applyZoneFilter(label, "tableView");
  };
  if (chartZones.canvas) chartZones.canvas.style.cursor = "pointer";
  chartZones.update();

  const famLabels = (stats.families || []).map(x => x.label);
  const famValues = (stats.families || []).map(x => x.value);
  chartFamilies?.destroy();
  chartFamilies = new Chart($("chartFamilies"), { type:"doughnut",
    data:{ labels:famLabels, datasets:[{
      data:famValues,
      backgroundColor:buildPalette(famLabels.length),
      borderColor:"#0b1020",
      borderWidth:1
    }] },
    options:{ responsive:true, plugins:{ legend:{ position:"bottom" } } }
  });
}

/** MapLibre **/
let map = null;
let popup = null;

const mapStyle = {
  version:8,
  glyphs:"https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf",
  sources:{ osm:{ type:"raster", tiles:["https://tile.openstreetmap.org/{z}/{x}/{y}.png"], tileSize:256, attribution:"© OpenStreetMap contributors" } },
  layers:[{ id:"osm", type:"raster", source:"osm" }]
};

function addOrUpdateSource(geojson){
  if (!map.getSource("obs")){
    map.addSource("obs", { type:"geojson", data:geojson, cluster:true, clusterMaxZoom:12, clusterRadius:50 });

    map.addLayer({ id:"clusters", type:"circle", source:"obs", filter:["has","point_count"],
      paint:{ "circle-radius":["step",["get","point_count"],16,50,22,200,28], "circle-opacity":0.75 }
    });
    map.addLayer({ id:"cluster-count", type:"symbol", source:"obs", filter:["has","point_count"],
      layout:{ "text-field":"{point_count_abbreviated}", "text-size":12 }
    });
    map.addLayer({ id:"unclustered-point", type:"circle", source:"obs", filter:["!",["has","point_count"]],
      paint:{ "circle-radius":6, "circle-opacity":0.9 }
    });

    map.on("click","clusters",(e)=>{
      const feats = map.queryRenderedFeatures(e.point,{ layers:["clusters"] });
      if (!feats.length) return;
      const clusterId = feats[0].properties.cluster_id;
      map.getSource("obs").getClusterExpansionZoom(clusterId,(err,zoom)=>{
        if (err) return;
        map.easeTo({ center:feats[0].geometry.coordinates, zoom });
      });
    });

    map.on("click","unclustered-point",(e)=>{
      const f = e.features[0];
      const p = f.properties;
      const zone = p.zone ?? "";
      const actions = zone ? [
        { label:"Tableau (zone)", onClick:()=>applyZoneFilter(zone, "tableView") },
        { label:"Stats (zone)", onClick:()=>applyZoneFilter(zone, "statsView") }
      ] : [];
      const content = createPopupContent(
        p.title ?? "Observation",
        [
          { label:"Zone", value:p.zone ?? "" },
          { label:"Site", value:p.site ?? "" },
          { label:"Famille", value:p.famille ?? "" },
          { label:"Date", value:p.date ?? "" },
          { label:"Effectif", value:p.effectif ?? "" }
        ],
        actions
      );
      popup?.remove();
      popup = new maplibregl.Popup({ closeButton:true }).setLngLat(f.geometry.coordinates).setDOMContent(content).addTo(map);
    });

    map.on("mouseenter","clusters",()=>map.getCanvas().style.cursor="pointer");
    map.on("mouseleave","clusters",()=>map.getCanvas().style.cursor="");
    map.on("mouseenter","unclustered-point",()=>map.getCanvas().style.cursor="pointer");
    map.on("mouseleave","unclustered-point",()=>map.getCanvas().style.cursor="");
  } else {
    map.getSource("obs").setData(geojson);
  }
}

function addOrUpdateSiteSource(geojson){
  if (!map) return;
  if (!map.getSource("sites")){
    map.addSource("sites", { type:"geojson", data:geojson });
    map.addLayer({
      id:"site-points",
      type:"circle",
      source:"sites",
      paint:{
        "circle-radius":6,
        "circle-color":["get","color"],
        "circle-opacity":0.95,
        "circle-stroke-width":1.5,
        "circle-stroke-color":"#f7f8ff"
      }
    });
    map.addLayer({
      id:"site-selected",
      type:"circle",
      source:"sites",
      filter:["==", ["get","site_norm"], "__none__"],
      paint:{
        "circle-radius":10,
        "circle-color":["get","color"],
        "circle-opacity":1,
        "circle-stroke-width":3,
        "circle-stroke-color":"#ffffff"
      }
    });
    map.addLayer({
      id:"site-labels",
      type:"symbol",
      source:"sites",
      minzoom:6,
      layout:{
        "text-field":["get","site"],
        "text-size":12,
        "text-offset":[0,1.1],
        "text-anchor":"top",
        "text-allow-overlap":false
      },
      paint:{
        "text-color":"#f7f8ff",
        "text-halo-color":"#0b1020",
        "text-halo-width":1.4,
        "text-halo-blur":0.4
      }
    });

    map.on("click","site-points",(e)=>{
      const f = e.features && e.features[0];
      if (!f) return;
      const p = f.properties || {};
      const siteName = p.site ?? "";
      const isZone = siteName && zoneNames.has(siteName);
      const actions = siteName ? [
        {
          label: isZone ? "Tableau (zone)" : "Tableau (site)",
          onClick: ()=> (isZone ? applyZoneFilter(siteName, "tableView") : applySiteFilter(siteName, "tableView"))
        },
        {
          label: isZone ? "Stats (zone)" : "Stats (site)",
          onClick: ()=> (isZone ? applyZoneFilter(siteName, "statsView") : applySiteFilter(siteName, "statsView"))
        }
      ] : [];
      const content = createPopupContent(
        siteName || "Site",
        [
          { label:"Lat", value:p.lat ?? "" },
          { label:"Lon", value:p.lon ?? "" }
        ],
        actions
      );
      popup?.remove();
      popup = new maplibregl.Popup({ closeButton:true }).setLngLat(f.geometry.coordinates).setDOMContent(content).addTo(map);
    });
    map.on("mouseenter","site-points",()=>map.getCanvas().style.cursor="pointer");
    map.on("mouseleave","site-points",()=>map.getCanvas().style.cursor="");
  } else {
    map.getSource("sites").setData(geojson);
  }
}

function updateSelectedSiteLayer(siteName){
  if (!map || (typeof map.isStyleLoaded === "function" && !map.isStyleLoaded())) return;
  if (!map.getLayer("site-selected")) return;
  const key = normalizeKey(siteName);
  if (key) {
    map.setFilter("site-selected", ["==", ["get","site_norm"], key]);
  } else {
    map.setFilter("site-selected", ["==", ["get","site_norm"], "__none__"]);
  }
}

function focusSelectedSite(siteName){
  if (!map || (typeof map.isStyleLoaded === "function" && !map.isStyleLoaded())) return false;
  const coord = resolveSiteCoords(siteName);
  if (!coord) return false;
  const lat = Number(coord.lat);
  const lon = Number(coord.lon);
  if (!Number.isFinite(lat) || !Number.isFinite(lon)) return false;
  map.easeTo({ center:[lon, lat], zoom:11 });
  return true;
}

function fitMapToGeojson(geojson){
  if (!map || !geojson || !Array.isArray(geojson.features) || !geojson.features.length) {
    return;
  }
  let minLon = Infinity, minLat = Infinity, maxLon = -Infinity, maxLat = -Infinity;
  for (const f of geojson.features) {
    const g = f && f.geometry;
    if (!g || g.type !== "Point") continue;
    const coords = Array.isArray(g.coordinates) ? g.coordinates : null;
    if (!coords || coords.length < 2) continue;
    const lon = Number(coords[0]);
    const lat = Number(coords[1]);
    if (!Number.isFinite(lon) || !Number.isFinite(lat)) continue;
    minLon = Math.min(minLon, lon);
    minLat = Math.min(minLat, lat);
    maxLon = Math.max(maxLon, lon);
    maxLat = Math.max(maxLat, lat);
  }
  if (!Number.isFinite(minLon)) return;
  map.fitBounds([[minLon, minLat], [maxLon, maxLat]], { padding:40, maxZoom:13 });
}

function debounce(fn, wait){
  let t;
  return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args),wait); };
}

async function initMap(){
  const hasMapLibre = !!window.maplibregl && typeof window.maplibregl.Map === "function";
  let canUseMap = false;
  if (hasMapLibre) {
    if (typeof window.maplibregl.supported === "function") {
      canUseMap = window.maplibregl.supported();
    } else if (typeof window.maplibregl.supported === "boolean") {
      canUseMap = window.maplibregl.supported;
    } else {
      canUseMap = true;
    }
  }
  if (!hasMapLibre || !canUseMap){
    $("tabMap").style.display = "none";
    document.getElementById("map").innerHTML =
      "<div class='notice'>MapLibre indisponible ou WebGL desactive sur ce navigateur/appareil. Utilise Tableau/Statistiques.</div>";
    setTab("tableView");
    return;
  }
  map = new maplibregl.Map({ container:"map", style:mapStyle, bounds:[[-17.7,12.1],[-11.3,16.9]], fitBoundsOptions:{ padding:20 }, maxBounds:[[-17.7,12.1],[-11.3,16.9]] });
  map.addControl(new maplibregl.NavigationControl(), "top-right");

  map.on("load", async ()=>{
    try {
      const geojson = await fetchGeo(true);
      addOrUpdateSource(geojson);
    } catch (err) {
      console.error(err);
      setNetStatus("error", "Erreur carte");
    }
    if (siteGeojson) {
      addOrUpdateSiteSource(siteGeojson);
      updateSelectedSiteLayer($("site").value);
    }
  });

  map.on("moveend", debounce(async ()=>{
    if (state.tab !== "mapView") return;
    if (!shouldUseBboxForGeo()) return;
    try {
      const geojson = await fetchGeo(true);
      addOrUpdateSource(geojson);
    } catch (err) {
      console.error(err);
      setNetStatus("error", "Erreur carte");
    }
  }, 350));
}

/** Orchestration **/
async function runSearch(){
  const requestId = ++state.requestId;
  state.filters = collectFilters();
  updateSelectedSiteLayer(state.filters.site);
  state.page = 1;
  setLoading(true);
  setNetStatus("loading", "Chargement...");

  try {
    let geoFailed = false;
    const useBbox = shouldUseBboxForGeo();
    const geoPromise = map ? fetchGeo(useBbox).catch(err => {
      geoFailed = true;
      console.error(err);
      return null;
    }) : null;

    const [tableResult, statsResult] = await Promise.allSettled([fetchTable(), fetchStats()]);
    if (requestId !== state.requestId) return;

    let hasError = false;
    if (tableResult.status === "fulfilled") {
      renderTable(tableResult.value);
    } else {
      hasError = true;
      console.error(tableResult.reason);
    }

    if (statsResult.status === "fulfilled") {
      renderCharts(statsResult.value);
    } else {
      hasError = true;
      console.error(statsResult.reason);
    }

    if (geoPromise) {
      const geojson = await geoPromise;
      if (geojson && requestId === state.requestId) {
        addOrUpdateSource(geojson);
        if (state.filters.site) {
          const focused = focusSelectedSite(state.filters.site);
          if (!focused) fitMapToGeojson(geojson);
        }
      }
    }

    if (geoFailed) {
      hasError = true;
    }

    setNetStatus(hasError ? "error" : "ok", hasError ? "Erreur API" : NET_LABEL);
  } catch (err) {
    if (requestId !== state.requestId) return;
    console.error(err);
    setNetStatus("error", "Erreur API");
  } finally {
    if (requestId === state.requestId) {
      setLoading(false);
    }
  }
}

async function runTablePage(){
  const requestId = ++state.requestId;
  setLoading(true);
  setNetStatus("loading", "Chargement...");
  try {
    const table = await fetchTable();
    if (requestId !== state.requestId) return;
    renderTable(table);
    setNetStatus("ok", NET_LABEL);
  } catch (err) {
    if (requestId !== state.requestId) return;
    console.error(err);
    setNetStatus("error", "Erreur API");
  } finally {
    if (requestId === state.requestId) {
      setLoading(false);
    }
  }
}

function resetFilters(){
  $("q").value=""; $("zone").value=""; $("site").value="";
  $("famille").value=""; $("dateFrom").value=""; $("dateTo").value="";
  $("countMin").value=""; $("countMax").value="";
}

/** Boot **/
(async function boot(){
  setNetStatus("ok", NET_LABEL);

  document.querySelectorAll(".tab").forEach(el => el.addEventListener("click", ()=>setTab(el.dataset.tab)));
  $("btnSearch").addEventListener("click", ()=>runSearch());
  $("btnReset").addEventListener("click", ()=>{ resetFilters(); runSearch(); });

  $("prevPage").addEventListener("click", ()=>{
    state.page = Math.max(1, state.page-1);
    runTablePage();
  });
  $("nextPage").addEventListener("click", ()=>{
    state.page = state.page+1;
    runTablePage();
  });

  // Populate filters
  let hasSiteCoords = false;
  try {
    siteCoords = await fetchSiteCoords();
    siteGeojson = buildSiteGeojson(siteCoords);
    const siteNames = Object.keys(siteCoords || {});
    if (siteNames.length) {
      populateSiteOptions(siteNames);
      hasSiteCoords = true;
    }
  } catch (err) {
    console.error(err);
  }

  try {
    const zones = await fetchZones();
    zoneNames = new Set(zones);
    for (const z of zones){
      const opt = document.createElement("option");
      opt.value = z; opt.textContent = z;
      $("zone").appendChild(opt);
    }

    if (!hasSiteCoords) {
      const sites = await fetchSites("");
      for (const s of sites){
        const opt = document.createElement("option");
        opt.value = s; opt.textContent = s;
        $("site").appendChild(opt);
      }
    }
  } catch (err) {
    console.error(err);
    setNetStatus("error", "Erreur API");
  }

  $("zone").addEventListener("change", async ()=>{
    const z = $("zone").value;
    if (siteCoords && Object.keys(siteCoords).length) return;
    $("site").innerHTML = "<option value=''>Tous</option>";
    try {
      const sitesZ = await fetchSites(z);
      for (const s of sitesZ){
        const opt = document.createElement("option");
        opt.value = s; opt.textContent = s;
        $("site").appendChild(opt);
      }
    } catch (err) {
      console.error(err);
      setNetStatus("error", "Erreur API");
    }
  });

  $("site").addEventListener("change", ()=>{
    updateSelectedSiteLayer($("site").value);
    focusSelectedSite($("site").value);
    runSearch();
  });

  await initMap();

  await runSearch();
})();
</script>
</body>
</html>
